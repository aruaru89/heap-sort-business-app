<!DOCTYPE html>
<html lang="th">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>การประยุกต์ใช้ Heap Sort สำหรับธุรกิจ</title>
  <style>
    body {
      font-family: 'Sarabun', sans-serif;
      line-height: 1.6;
      margin: 2rem;
      background-color: #f9f9f9;
      color: #333;
    }
    h1, h2 {
      color: #004085;
    }
    hr {
      margin: 2rem 0;
      border: none;
      border-top: 2px solid #000000;
    }
    .section {
      margin-bottom: 2rem;
    }
  </style>
</head>
<body>
  <h1>การประยุกต์โดยการใช้ Heap Sort สำหรับการแก้ปัญหาทางธุรกิจ</h1>
  
<hr>
  <div class="section">
    <h2>ปัญหาทางธุรกิจ</h2>
    <p><strong>ปัญหาการค้นหาทะเบียนรถที่ต้องการ</strong> คือการศึกษาและพัฒนากระบวนการทางคอมพิวเตอร์เพื่อให้สามารถค้นหาข้อมูลทะเบียนรถที่มีอยู่ในฐานข้อมูลหรือระบบได้อย่างถูกต้อง แม่นยำ และมีประสิทธิภาพสูง การค้นหาดังกล่าวอาจอยู่ภายใต้ข้อจำกัดหรือเงื่อนไขที่แตกต่างกัน เช่น การค้นหาแบบตรงตัว (Exact Match) ที่ต้องการผลลัพธ์ที่ตรงกับข้อมูลที่ป้อนเข้ามาทุกตัวอักษรหรือการค้นหาแบบบางส่วน (Partial Match) ที่อนุญาตให้ค้นหาข้อมูลจากส่วนหนึ่งของข้อมูลทะเบียนรถ นอกจากนี้ยังรวมถึงการค้นหาแบบคลาดเคลื่อน (Fuzzy Search) ซึ่งรองรับกรณีที่ผู้ใช้กรอกข้อมูลผิดพลาดเพียงเล็กน้อย เช่น พิมพ์ผิดตัวอักษรหรือสลับตำแหน่งตัวอักษรบางตัวเพื่อให้ระบบสามารถแนะนำหรือค้นหาทะเบียนที่ใกล้เคียงที่สุดได้</p>
    <strong>ตัวอย่างการประยุกต์ปัญหาการค้นหาในทางธุรกิจ</strong>
    <p>ปัญหาการค้นหาทะเบียนรถที่ต้องการ หมายถึง สถานการณ์ที่เราต้องการค้นหาข้อมูลของรถคันหนึ่ง โดยใช้ "หมายเลขทะเบียนรถ" เป็นตัวระบุแต่เกิดความยุ่งยากหรือเสียเวลาในการค้นหาด้วยเหตุผลต่าง ๆ เช่น จำนวนทะเบียนรถที่มีมาก , ข้อมูลไม่เป็นระเบียบ , ป้อนข้อมูลผิดพลาด , การค้นหาแบบกำกวม , ระบบค้นหาไม่มีฟีเจอร์ที่ดีพอ</p>
<br>
    <strong>ประโยชน์ของการใช้</strong>
    <ol>
        <li><p>ด้านความปลอดภัยและกฎหมาย : ติดตามรถต้องสงสัยหรือรถที่เกี่ยวข้องกับคดี, ตรวจสอบความถูกต้องของรถก่อนซื้อ-ขาย, ป้องกันอาชญากรรมด้วยระบบ AI + CCTV</li>
        <li><p>ด้านธุรกิจและการขนส่ง : บริหารจัดการรถในองค์กร, เพิ่มความเร็วในการค้นหาข้อมูลลูกค้า</li>
        <li><p>ด้านบริการประชาชน : อำนวยความสะดวกในการชำระภาษี-ต่อทะเบียน, ตรวจสอบประวัติรถมือสองก่อนซื้อ</li>
        <li><p>ด้านเทคโนโลยีและระบบอัตโนมัติ : ใช้ร่วมกับระบบ AI / Machine Learning, พัฒนา Smart City ด้วยข้อมูลจากทะเบียนรถ</li>
    </ol>
  </div>

<hr>
  <div class="section">
    <h2>Algorithm ที่ใช้ในการเปรียบเทียบ</h2>
    <strong>การเรียงลำดับแบบฟอง (Bubble Sort)</strong>
    <p>เป็นวิธีการเรียงลำดับข้อมูลง่าย ๆ วิธีหนึ่งโดยการเรียงลำดับวิธีนี้จะทำการเปรียบเทียบ 2 ค่าที่อยู่ติดกันแล้วสลับเพื่อให้เรียงลำดับโดยเริ่มเปรียบจากตัวที่ 1 กับ 2 และ 2 กับ 3 ไปเรื่อย ๆ จนกว่าครบทุกค่าแล้วทำซ้ำอีกจนกว่าจะไม่มีการสลับที่</p>
    <p><strong>ตัวอย่าง</strong> แสดงการเรียงลำดับแบบฟอง จากตัวเลขต่อไปนี้ 4,5,6,8,2</p>
<!DOCTYPE html>
<html lang="th">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>การประยุกต์ใช้ Heap Sort สำหรับธุรกิจ</title>
  <style>
    body {
      font-family: 'Sarabun', sans-serif;
      line-height: 1.6;
      margin: 2rem;
      background-color: #f9f9f9;
      color: #333;
    }

    h1, h2 {
      color: #004085;
    }

    hr {
      margin: 2rem 0;
      border: none;
      border-top: 2px solid #ccc;
    }

    .section {
      margin-bottom: 2rem;
    }

    .highlight-red {
      color: red;
      font-weight: bold;
    }
          </style>
        </head>
        <body>
        <p class="round">รอบที่ 1: <span class="highlight-red">4</span>, <span class="highlight-red">5</span>, 6, 8, 2</p>
        <p class="round">รอบที่ 2: 4, <span class="highlight-red">5</span>, <span class="highlight-red">6</span>, 8, 2</p>
        <p class="round">รอบที่ 3: 4, 5, <span class="highlight-red">6</span>, <span class="highlight-red">8</span>, 2</p>
        <p class="round">รอบที่ 4: 4, 5, 6, <span class="highlight-red">8</span>, <span class="highlight-red">2</span></p>
        <p><strong>เริ่มใหม่</strong>
        <p class="round">รอบที่ 1: <span class="highlight-red">4</span>, <span class="highlight-red">5</span>, 2, 6, 8</p>
        <p class="round">รอบที่ 2: 4, <span class="highlight-red">2</span>, <span class="highlight-red">5</span>, 6, 8</p>
        <p class="round">รอบที่ 3: 4, 2, <span class="highlight-red">5</span>, <span class="highlight-red">6</span>, 8</p>
        <p class="round">รอบที่ 4: 4, 2, 5, <span class="highlight-red">6</span>, <span class="highlight-red">8</span></p>
        <p><strong>เริ่มใหม่</strong>
        <p class="round">รอบที่ 1: <span class="highlight-red">4</span>, <span class="highlight-red">5</span>, 2, 6, 8</p>
        <p class="round">รอบที่ 2: 4, <span class="highlight-red">2</span>, <span class="highlight-red">5</span>, 6, 8</p>
        <p class="round">รอบที่ 3: 4, 2, <span class="highlight-red">5</span>, <span class="highlight-red">6</span>, 8</p>
        <p class="round">รอบที่ 4: 4, 2, 5, <span class="highlight-red">6</span>, <span class="highlight-red">8</span></p>
        <p><strong>เริ่มใหม่</strong>
        <p class="round">รอบที่ 1: <span class="highlight-red">2</span>, <span class="highlight-red">4</span>, 5, 6, 8</p>
        <p class="round">รอบที่ 2: 2, <span class="highlight-red">4</span>, <span class="highlight-red">5</span>, 6, 8</p>
        <p class="round">รอบที่ 3: 2, 4, <span class="highlight-red">5</span>, <span class="highlight-red">6</span>, 8</p>
        <p class="round">รอบที่ 4: 2, 4, 5, <span class="highlight-red">6</span>, <span class="highlight-red">8</span></p>
        </body>
        </html>   
<br>
    <p><strong>จากตัวอย่างจะได้ว่า</strong> มีการเปรียบเทียบข้อมูลที่อยู่ติดกันซึ่งจะทำการสลับที่กันถ้าข้อมูลไม่เรียงลำดับตามที่ต้องการ และจะทำซ้ำไปเรื่อย ๆ จนกว่าจะไม่มีการสลับที่ก็จะได้ข้อมูลที่เรียงลำดับประสิทธิภาพของ Bubble Sort สามารถแบ่งออกเป็น 2 กรณี คือ</p>
    <ol>
        <li><p>กรณีที่แย่ที่สุด (Worst Case) เป็นกรณีที่ต้องใช้จำนวนครั้งในการเปรียบเทียบมากที่สุดนั่นคือถ้ามีไฟล์มีขนาด n ต้องใช้จำนวนครั้งในการเปรียบเทียบมากที่สุดคือ จำนวน n - 1 ครั้ง และในแต่ละรอบจะมีจำนวนครั้งในการเปรียบเทียบดังนี้</p>
        <p> รอบที่ 1 ต้องเปรียบเทียบ n - 1 ครั้ง รอบที่ 2 ต้องเปรียบเทียบ n - 2 ครั้ง รอบที่ 3 ต้องเปรียบเทียบ n - 3 ครั้ง รอบที่ n - 2 ต้องเปรียบเทียบ 2 ครั้ง รอบที่ n - 1 ต้องเปรียบเทียบ 1 ครั้ง</p>
        ซึ่งถ้ารวมจำนวนครั้งของทุก ๆ รอบแล้ว จะได้เท่ากับ... (n - 1) + (n - 2) + (n - 3) + ... + 2 + 1 = n(n - 1) /2 ครั้ง รวมเวลาที่ใช้ประมาณ O(n^2) ครั้ง รวมเวลาที่ใช้ประมาณ O(n^2) ข้อมูลที่นำมาเรียงลำดับจะมีประสิทธิภาพแย่ที่สุดก็ต่อเมื่อข้อมูลเดิมที่จะนำมาเรียงลำดับมีการเรียงอยู่แล้วในลักษณะหนึ่ง แต่ต้องการเรียงใหม่ให้ข้อมูลอยู่ในทิศทางที่ตรงกันข้ามเช่น เดิมข้อมูล เรียงลำดับจากมากไปหาน้อย แต่ต้องการเรียงใหม่ให้ข้อมูลเรียงลำดับจากน้อยไปหามาก เป็นต้น</p>
        <li><p>กรณีที่ดีที่สุด (Best Case) เป็นกรณีที่จำนวนครั้งของการเปรียบเทียบข้อมูลมีน้อยที่สุดคือ เท่ากับ 1 ครั้งในรอบเดียว หรือใช้เวลาประมาณ O(n) เท่านั้น ซึ่งกรณีเช่นนี้จะเกิดขึ้นได้ก็ต่อเมื่อข้อมูลที่ต้องการนำมาเรียงลำดับนั้น มีการเรียงลำดับอยู่ก่อนแล้ว</p>      
    </ol>
<hr>

</div>
  <div class="section">
    <h2>Code Algorithm ที่ใช้ในการเปรียบเทียบ</h2>
    <table border="1" cellspacing="0" cellpadding="5">
      <tr>
        <th>Line</th>
        <th>Code</th>
      </tr>
      <tr><td>1</td><td>import time</td></tr>
      <tr><td>2</td><td>import os</td></tr>
      <tr><td>3</td><td>app = Flask(__name__))</td></tr>
      <tr><td>4</td><td>def bubble_sort(arr):</td></tr>
      <tr><td>5</td><td>&nbsp;&nbsp;n = len(arr)</td></tr>
      <tr><td>6</td><td>&nbsp;&nbsp;for i in range(n):</td></tr>
      <tr><td>7</td><td>&nbsp;&nbsp;&nbsp;for j in range(0, n - i - 1):</td></tr>
      <tr><td>8</td><td>&nbsp;&nbsp;&nbsp;&nbsp;if arr[j] > arr[j + 1]:</td></tr>
      <tr><td>9</td><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr[j], arr[j + 1] = arr[j + 1], arr[j]</td></tr>
      <tr><td>10</td><td>&nbsp;&nbsp;return arr</td></tr>
      <tr><td>11</td><td>def load_data():</td></tr>
      <tr><td>12</td><td>&nbsp;&nbsp;path = os.path.join(app.root_path, 'data.txt')</td></tr>
      <tr><td>13</td><td>&nbsp;&nbsp;if not os.path.exists(path):</td></tr>
      <tr><td>14</td><td>&nbsp;&nbsp;&nbsp;return []</td></tr>
      <tr><td>15</td><td>&nbsp;&nbsp;with open(path, encoding='utf-8') as f:</td></tr>
      <tr><td>16</td><td>&nbsp;&nbsp;&nbsp;return [line.strip() for line in f if line.strip()]</td></tr>
      <tr><td>17</td><td>@app.route('/', methods=['GET', 'POST'])</td></tr>
      <tr><td>18</td><td>def index():</td>
      <tr><td>19</td><td>&nbsp;&nbsp;default_data = load_data()</td>
      <tr><td>20</td><td>&nbsp;&nbsp;sorted_data = []</td>
      <tr><td>21</td><td>&nbsp;&nbsp;result = None</td>
      <tr><td>22</td><td>&nbsp;&nbsp;elapsed = 0</td></tr>
      <tr><td>23</td><td>&nbsp;&nbsp;if request.method == 'POST':</td></tr>
      <tr><td>24</td><td>&nbsp;&nbsp;&nbsp;raw = request.form.get('data','').strip()</td></tr>
      <tr><td>25</td><td>&nbsp;&nbsp;&nbsp;arr = raw.splitlines() if raw else default_data</td></tr>
      <tr><td>26</td><td>&nbsp;&nbsp;&nbsp;arr = [line.strip() for line in arr if line.strip()]</td></tr>
      <tr><td>27</td><td>&nbsp;&nbsp;&nbsp;key = request.form.get('search','').strip()</td></tr>
      <tr><td>28</td><td>&nbsp;&nbsp;&nbsp;t0 = time.time()</td></tr>
      <tr><td>29</td><td>&nbsp;&nbsp;&nbsp;sorted_data = bubble_sort(arr.copy())</td></tr>
      <tr><td>30</td><td>&nbsp;&nbsp;&nbsp;elapsed = round(time.time() - t0, 6)</td></tr>
      <tr><td>31</td><td>&nbsp;&nbsp;&nbsp;if key:</td></tr>
      <tr><td>32</td><td>&nbsp;&nbsp;&nbsp;&nbsp;if key in sorted_data:</td></tr>
      <tr><td>33</td><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pos = sorted_data.index(key) + 1</td></tr>
      <tr><td>34</td><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result = f"พบทะเบียน {key} ในลำดับที่ {pos}"</td></tr>
      <tr><td>35</td><td>&nbsp;&nbsp;&nbsp;&nbsp;else:</td></tr>
      <tr><td>36</td><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;matches = [p for p in sorted_data if key in p]</td></tr>
      <tr><td>37</td><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if matches:</td></tr>
      <tr><td>38</td><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result = f"พบทะเบียนที่มี '{key}': {', '.join(matches[:5])}"</td></tr>
      <tr><td>39</td><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:</td></tr>
      <tr><td>40</td><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result = f"ไม่พบทะเบียน {key} ในรายการ"</td></tr>
      <tr><td>41</td><td>&nbsp;&nbsp;&nbsp;return render_template(</td></tr>
      <tr><td>42</td><td>&nbsp;&nbsp;&nbsp;&nbsp;'index.html',</td></tr>
      <tr><td>43</td><td>&nbsp;&nbsp;&nbsp;&nbsp;data_input=default_data,</td></tr>
      <tr><td>44</td><td>&nbsp;&nbsp;&nbsp;&nbsp;sorted_data=sorted_data,</td></tr>
      <tr><td>45</td><td>&nbsp;&nbsp;&nbsp;&nbsp;time=elapsed,</td></tr>
      <tr><td>46</td><td>&nbsp;&nbsp;&nbsp;&nbsp;result=result</td></tr>
      <tr><td>47</td><td>if __name__ == '__main__':</td></tr>
      <tr><td>48</td><td>&nbsp;&nbsp;app.run(debug=True, host='0.0.0.0', port=5005)</td></tr>

    </table>
<hr>

</div>
<div class="section">
  <h2>Algorithm ที่นำเสนอ</h2>
  <strong>การเรียงข้อมูลแบบฮีป (Heap Sort)</strong>
  <p>การเรียบข้อมูลแบบฮีป คือ การจัดเรียงข้อมูลโดยอาศัยหลักการหรือโครงสร้างของไบนารีทรี (Binary Tree) มาเป็นกระบวนการหลักในการทำงานซึ่งวิธีการเรียงลำดับแบบไบนารีทรีนี้เป็นวิธีที่ดีที่สุดของการเรียงข้อมูลทั้งยังสามารถทำงานได้ดีในข้อมูลที่ซับซ้อนมาก ๆ แม้ว่าค่าเฉลี่ยของการทำงานอาจจะไม่ได้เร็วที่สุดก็ตาม (ในกรณีที่มีปัจจัยอื่น ๆ คงที่) แต่คุณสมบัติของฮีปก็ยังสามารถเรียงลำดับชุดข้อมูลที่มีขนาดใหญ่ และซับซ้อนได้ดีกว่าการเรียงข้อมูลแบบอื่น</p>

<br>
  <p>จากที่ได้กล่าวมาในข้างต้นถึงกระบวนการทำงานของฮีปซึ่งอาศัยหลักการของไบนารีทรีในการดำเนินการนั้น หากจะนับว่าโครงสร้างดังกล่าวเป็นฮีปทรี (Heap Tree) ได้นั้นต้องอยู่ภายใต้เงื่อนไขดังต่อไปนี้</p>
  <ol>
        <li><p>ในทุก ๆ ระดับของฮีปทรี นั้นจะสามารถแตกสาขาออกไปได้ทั้งซ้ายและขวา เรื่อมจากการแตกสาขาออกไปทางซ้ายก่อนแล้วค่อยไปทางขวา และต้องมีโหนดให้ครบทั้งสองด้านก่อน จึงจะสามารถแตกโหนดต่อไปได้</p>
        <li><p>โหนดในระดับที่สูงกว่า หรือคีย์โหนดจะต้องอยู่ในลักษณะของโหนดตัวแม่ กล่าวคือจะต้องมีค่ามากกว่าโหนดลูกเสมอ</p>
  </ol>
</div>
      <!DOCTYPE html>
      <html lang="th">
      <head>
        <meta charset="UTF-8">
        <title>แสดงภาพ</title>
      </head>
      <body>
      
        <img src="ภาพที่ 1 ภาพแสดงการจัดเรียงที่ตรงตามคุณสมบัติของฮีปทรี.png" alt="ภาพที่ 1 ภาพแสดงการจัดเรียงที่ตรงตามคุณสมบัติของฮีปทรี.png" width="1000">
        <p><strong>ภาพที่ 2</strong> ภาพแสดงการจัดเรียงที่ตรงตามคุณสมบัติของฮีปทรี (Heap Tree)</p>
      
      </body>
      </html>
    </ol>
<hr>

</div>
<div class="section">
  <h2>Code Algorithm ที่ใช้ในการเปรียบเทียบ</h2>
  <table border="1" cellspacing="0" cellpadding="5">
    <tr>
      <th>Line</th>
      <th>Code</th>
    </tr>
    <tr><td>1</td><td>import time</td></tr>
    <tr><td>2</td><td>import os</td></tr>
    <tr><td>3</td><td>app = Flask(__name__))</td></tr>
    <tr><td>4</td><td>def heapify(arr, n, i):</td></tr>
    <tr><td>5</td><td>&nbsp;&nbsp;largest = i</td></tr>
    <tr><td>6</td><td>&nbsp;&nbsp;l = 2 * i + 1</td></tr>
    <tr><td>7</td><td>&nbsp;&nbsp;r = 2 * i + 2</td></tr>
    <tr><td>8</td><td>&nbsp;&nbsp;if l < n and arr[i] < arr[l]:</td></tr>
    <tr><td>9</td><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;largest = l</td></tr>
    <tr><td>10</td><td>&nbsp;&nbsp;if r < n and arr[largest] < arr[r]:</td></tr>
    <tr><td>11</td><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;largest = r</td></tr>
    <tr><td>12</td><td>&nbsp;&nbsp;if largest != i:</td></tr>
    <tr><td>13</td><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr[i], arr[largest] = arr[largest], arr[i]</td></tr>
    <tr><td>14</td><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;heapify(arr, n, largest)</td></tr>
    <tr><td>15</td><td>def heap_sort(arr):</td></tr>
    <tr><td>16</td><td>&nbsp;&nbsp;n = len(arr)</td></tr>
    <tr><td>17</td><td>&nbsp;&nbsp;heapify(arr, n, i)</td></tr>
    <tr><td>18</td><td>&nbsp;&nbsp;for i in range(n - 1, 0, -1):</td>
    <tr><td>19</td><td>&nbsp;&nbsp;&nbsp;arr[0], arr[i] = arr[i], arr[0]</td>
    <tr><td>20</td><td>&nbsp;&nbsp;&nbsp;heapify(arr, i, 0)</td>
    <tr><td>21</td><td>&nbsp;&nbsp;return arr</td>
    <tr><td>22</td><td>@app.route('/', methods=['GET', 'POST'])</td></tr>
    <tr><td>23</td><td>def index():</td></tr>
    <tr><td>24</td><td>&nbsp;&nbsp;sorted_data = []</td></tr>
    <tr><td>25</td><td>&nbsp;&nbsp;search_result = None</td></tr>
    <tr><td>26</td><td>&nbsp;&nbsp;elapsed_time = 0</td></tr>
    <tr><td>27</td><td>&nbsp;&nbsp;data_file = os.path.join(app.root_path, 'data.txt')</td></tr>
    <tr><td>28</td><td>&nbsp;&nbsp;if os.path.exists(data_file):</td></tr>
    <tr><td>29</td><td>&nbsp;&nbsp;&nbsp;with open(data_file, 'r', encoding='utf-8') as f:</td></tr>
    <tr><td>30</td><td>&nbsp;&nbsp;&nbsp;&nbsp;default_data = [line.strip() for line in f if line.strip()]</td></tr>
    <tr><td>31</td><td>&nbsp;&nbsp;else:</td></tr>
    <tr><td>32</td><td>&nbsp;&nbsp;&nbsp;default_data = []</td></tr>
    <tr><td>33</td><td>&nbsp;&nbsp;if request.method == 'POST':</td></tr>
    <tr><td>34</td><td>&nbsp;&nbsp;&nbsp;raw = request.form.get('data', '').strip()</td></tr>
    <tr><td>35</td><td>&nbsp;&nbsp;&nbsp;input_data = raw.splitlines() if raw else default_data</td></tr>
    <tr><td>36</td><td>&nbsp;&nbsp;&nbsp;input_data = [line.strip() for line in input_data if line.strip()]</td></tr>
    <tr><td>37</td><td>&nbsp;&nbsp;&nbsp;start = time.time()</td></tr>
    <tr><td>38</td><td>&nbsp;&nbsp;&nbsp;sorted_data = heap_sort(input_data.copy())</td></tr>
    <tr><td>39</td><td>&nbsp;&nbsp;&nbsp;elapsed_time = round(time.time() - start, 6)</td></tr>
    <tr><td>40</td><td>&nbsp;&nbsp;&nbsp;if search_input:</td></tr>
    <tr><td>41</td><td>&nbsp;&nbsp;&nbsp;&nbsp;if search_input in sorted_data:</td></tr>
    <tr><td>42</td><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pos = sorted_data.index(search_input) + 1</td></tr>
    <tr><td>43</td><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;search_result = f"พบทะเบียน {search_input} ในลำดับที่ {pos}"</td></tr>
    <tr><td>44</td><td>&nbsp;&nbsp;&nbsp;&nbsp;else:</td></tr>
    <tr><td>45</td><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;search_result = f"ไม่พบทะเบียน {search_input} ในรายการ"</td></tr>
    <tr><td>46</td><td>&nbsp;&nbsp;return render_template('index.html', data_input=default_data,</td></tr>
    <tr><td>47</td><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sorted_data=sorted_data,</td></tr>
    <tr><td>48</td><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;time=elapsed_time,</td></tr>
    <tr><td>49</td><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result=search_result)</td></tr>
    <tr><td>50</td><td>if __name__ == '__main__':</td></tr>
    <tr><td>51</td><td>&nbsp;&nbsp;app.run(debug=True, host='0.0.0.0', port=5003)</td></tr>
  </table>
<hr>

</div>
<div class="section">
  <h2>ประยุกต์อย่างไร</h2>
  <strong>ผลการทดลอง</strong>
  <p><strong>จากผลการทดลองพบว่า</strong> เวลาที่ใช้ในการเรียงข้อมูลทะเบียนรถจำนวน 1,000 รายการ</p>
  <p class="round"> → Heap Sort ใช้เวลา 0.015 วินาที</p>
  <p class="round"> → Bubble Sort ใช้เวลา 1.627 วินาที</p>
    
  <p>ในขณะที่เวลาที่ใช้ในการค้นหาทะเบียนรถจากข้อมูลเรียงแล้ว (500 รายการ)</p>
  <p class="round"> → ใช้การค้นหาแบบแมป (dict) ซึ่งให้ผลลัพธ์ทันที (O(1))</p>
  <p class="round"> → ใช้เวลาเท่ากัน คือประมาณ 0.002 วินาที</p>
  <p><strong>ดังนั้น</strong> ถึงแม้ว่าทั้งสองวิธีจะให้ผลลัพธ์การค้นหาที่ถูกต้องเหมือนกัน แต่ Heap Sort ใช้เวลาในการเรียงข้อมูลน้อยกว่ามาก
    ทำให้การนำ Heap Sort ไปประยุกต์ใช้กับการจัดเรียงและค้นหาข้อมูลมีประสิทธิภาพสูงกว่า และสามารถนำไปใช้กับระบบข้อมูลขนาดใหญ่หรือแบบเรียลไทม์ได้จริง</p>

<br>
  <strong>อธิบายประโยชน์ทางธุรกิจ</strong>
  <ol>
      <li><p>เพิ่มประสิทธิภาพในการจัดการข้อมูลจำนวนมาก โดยเรียงลำดับข้อมูลได้เร็วถึง (O(n log n))</p>
      <li><p>ค้นหาข้อมูลได้เร็วขึ้นหลังเรียง ช่วยลดภาระเซิร์ฟเวอร์หรือลดต้นทุนการประมวลผล</p>
      <li><p>รองรับการเติบโตของระบบ เมื่อข้อมูลเพิ่มขึ้น ระบบยังคงตอบสนองได้ดี</p>
      <li><p>เหมาะกับระบบอัตโนมัติและเรียลไทม์ เพราะสามารถฝังในระบบแบบเบื้องหลัง (background) โดยไม่กินทรัพยากรเกินจำเป็น</p>
      <li><p>ลดต้นทุนในระยะยาว</p>
      <p class="round"> ความเร็วของอัลกอริทึม → แปลว่าเซิร์ฟเวอร์ทำงานน้อยลง → ประหยัดค่าใช้จ่าย Cloud / Hardware</p>
      <p class="round"> ประมวลผลไว = ลูกค้าไม่ต้องรอ → ประสบการณ์ใช้งานดีขึ้น → เพิ่มโอกาสขาย/ใช้บริการซ้ำ</p>
    </ol>
  </div>
  <strong>สรุปประโยชน์ทางธุรกิจ</strong>
  <p>Heap Sort เป็นเครื่องมือที่มีประโยชน์มากในการจัดการข้อมูลปริมาณมากอย่างมีประสิทธิภาพหากนำไปใช้ในระบบหลังบ้านหรือระบบแสดงข้อมูลแบบเรียลไทม์จะช่วยให้ธุรกิจ เร็วขึ้น, ตอบสนองไวขึ้น, และ ต้นทุนต่ำลงอย่างมีนัยสำคัญ</p>

<hr>

</div>
<div class="section">
  <h2>Resource</h2>
  <center>
    <a href="search.html" target="_blank">search.txt</a><br>
    <a href="data.html" target="_blank">data.txt</a><br>
    </center>
<hr>

</div>
<div class="section">
  <h2>วิดีโอที่ใช้นำเสนอ</h2>

<hr>  

<div class="section">
  <h2>จัดทำโดย</h2>

  <!DOCTYPE html>
  <html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>รูปภาพด้านข้างข้อความ</title>
    <style>
      .container {
        display: flex;
        align-items: center;
      }
      .container img {
        width: 200px;
        height: auto;
        margin-right: 20px;
      }
    </style>
  </head>
  <body>
  
    <div class="container">
      <img src="aa.jpg" alt>
      <div>
        <h2>นางสาวอรุจิรา จีนไธสง ชื่อเล่น อ๋อมแอ๋ม</h2>
        <p>รหัสนักศึกษา 6724650137</p>
        <p>นักศึกษาชั้นปีที่ 1 คณะสหวิทยาการ สาขาวิทยาศาสตร์และนวัตกรรมข้อมูล</p>
        <p>มหาวิทยาลัยธรรมศาสตร์ ศูนย์รังสิต</p>
      </div>
    </div>
  
  </body>
  </html>
  